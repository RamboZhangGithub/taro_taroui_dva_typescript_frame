"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createApp = exports.createPage = exports.TEMPLATE_CREATOR = void 0;
const fs = require("fs-extra");
const path = require("path");
const child_process_1 = require("child_process");
const ora = require("ora");
const helper_1 = require("@tarojs/helper");
const util_1 = require("../util");
const CONFIG_DIR_NAME = 'config';
exports.TEMPLATE_CREATOR = 'template_creator.js';
const styleExtMap = {
    sass: 'scss',
    less: 'less',
    stylus: 'styl',
    none: 'css'
};
const doNotCopyFiles = ['.DS_Store', '.npmrc', exports.TEMPLATE_CREATOR];
function createFiles(creater, files, handler, options) {
    const { description, projectName, version, css, date, typescript, template, templatePath, projectPath, pageName, framework } = options;
    const logs = [];
    // æ¨¡æ¿åº“æ¨¡æ¿ï¼Œç›´æ¥åˆ›å»ºï¼Œä¸éœ€è¦æ”¹åç¼€
    const globalChangeExt = Boolean(handler);
    const currentStyleExt = styleExtMap[css] || 'css';
    files.forEach(file => {
        // fileRePath startsWith '/'
        const fileRePath = file.replace(templatePath, '').replace(new RegExp(`\\${path.sep}`, 'g'), '/');
        let externalConfig = null;
        const isVueFramework = /^vue/.test(framework);
        if (isVueFramework && file.endsWith('.jsx')) {
            return;
        }
        if (!isVueFramework && file.endsWith('.vue')) {
            return;
        }
        // è·‘è‡ªå®šä¹‰é€»è¾‘ï¼Œç¡®å®šæ˜¯å¦åˆ›å»ºæ­¤æ–‡ä»¶
        if (handler && typeof handler[fileRePath] === 'function') {
            externalConfig = handler[fileRePath](options);
            if (!externalConfig)
                return;
        }
        let changeExt = globalChangeExt;
        if (externalConfig && typeof externalConfig === 'object') {
            if (externalConfig.changeExt === false) {
                changeExt = false;
            }
        }
        // åˆå¹¶è‡ªå®šä¹‰ config
        const config = Object.assign({}, {
            description,
            projectName,
            version,
            css,
            cssExt: currentStyleExt,
            date,
            typescript,
            template,
            pageName,
            framework
        }, externalConfig);
        let destRePath = fileRePath;
        // createPage åˆ›å»ºé¡µé¢æ¨¡å¼
        if (config.setPageName) {
            destRePath = config.setPageName;
        }
        destRePath = destRePath.replace(/^\//, '');
        // å¤„ç† .js å’Œ .css çš„åç¼€
        if (typescript &&
            changeExt &&
            !destRePath.startsWith(`${CONFIG_DIR_NAME}`) &&
            (path.extname(destRePath) === '.js' || path.extname(destRePath) === '.jsx') &&
            !(destRePath.endsWith('babel.config.js') || destRePath.endsWith('.eslintrc.js'))) {
            destRePath = destRePath.replace('.js', '.ts');
        }
        if (changeExt && path.extname(destRePath).includes('.css')) {
            destRePath = destRePath.replace('.css', `.${currentStyleExt}`);
        }
        // åˆ›å»º
        creater.template(template, fileRePath, path.join(projectPath, destRePath), config);
        const destinationPath = creater.destinationPath(path.join(projectPath, destRePath));
        logs.push(`${helper_1.chalk.green('âœ” ')}${helper_1.chalk.grey(`åˆ›å»ºæ–‡ä»¶: ${destinationPath}`)}`);
    });
    return logs;
}
function createPage(creater, params, cb) {
    return __awaiter(this, void 0, void 0, function* () {
        const { projectDir, template, pageName } = params;
        // path
        const templatePath = creater.templatePath(template);
        if (!fs.existsSync(templatePath))
            return console.log(helper_1.chalk.red(`åˆ›å»ºé¡µé¢é”™è¯¯ï¼šæ‰¾ä¸åˆ°æ¨¡æ¿${templatePath}`));
        // å¼•å…¥æ¨¡æ¿ç¼–å†™è€…çš„è‡ªå®šä¹‰é€»è¾‘
        const handlerPath = path.join(templatePath, exports.TEMPLATE_CREATOR);
        const basePageFiles = fs.existsSync(handlerPath) ? require(handlerPath).basePageFiles : [];
        const files = Array.isArray(basePageFiles) ? basePageFiles : [];
        const handler = fs.existsSync(handlerPath) ? require(handlerPath).handler : null;
        const logs = createFiles(creater, files, handler, Object.assign(Object.assign({}, params), { templatePath, projectPath: projectDir, pageName, period: 'createPage' }));
        creater.fs.commit(() => {
            // logs
            console.log();
            logs.forEach(log => console.log(log));
            console.log();
            typeof cb === 'function' && cb();
        });
    });
}
exports.createPage = createPage;
function createApp(creater, params, cb) {
    return __awaiter(this, void 0, void 0, function* () {
        const { projectName, projectDir, template, autoInstall = true, framework } = params;
        const logs = [];
        // path
        const templatePath = creater.templatePath(template);
        const projectPath = path.join(projectDir, projectName);
        // npm & yarn
        const version = util_1.getPkgVersion();
        const isShouldUseYarn = helper_1.shouldUseYarn();
        const useNpmrc = !isShouldUseYarn;
        const yarnLockfilePath = path.join('yarn-lockfiles', `${version}-yarn.lock`);
        const useYarnLock = isShouldUseYarn && fs.existsSync(creater.templatePath(template, yarnLockfilePath));
        if (useNpmrc) {
            creater.template(template, '.npmrc', path.join(projectPath, '.npmrc'));
            logs.push(`${helper_1.chalk.green('âœ” ')}${helper_1.chalk.grey(`åˆ›å»ºæ–‡ä»¶: ${projectName}${path.sep}.npmrc`)}`);
        }
        if (useYarnLock) {
            creater.template(template, yarnLockfilePath, path.join(projectPath, 'yarn.lock'));
            logs.push(`${helper_1.chalk.green('âœ” ')}${helper_1.chalk.grey(`åˆ›å»ºæ–‡ä»¶: ${projectName}${path.sep}yarn.lock`)}`);
        }
        // éå†å‡ºæ¨¡æ¿ä¸­æ‰€æœ‰æ–‡ä»¶
        const files = yield util_1.getAllFilesInFloder(templatePath, doNotCopyFiles);
        // å¼•å…¥æ¨¡æ¿ç¼–å†™è€…çš„è‡ªå®šä¹‰é€»è¾‘
        const handlerPath = path.join(templatePath, exports.TEMPLATE_CREATOR);
        const handler = fs.existsSync(handlerPath) ? require(handlerPath).handler : null;
        // ä¸ºæ‰€æœ‰æ–‡ä»¶è¿›è¡Œåˆ›å»º
        logs.push(...createFiles(creater, files, handler, Object.assign(Object.assign({}, params), { framework,
            version,
            templatePath,
            projectPath, pageName: 'index', period: 'createApp' })));
        // fs commit
        creater.fs.commit(() => {
            // logs
            console.log();
            console.log(`${helper_1.chalk.green('âœ” ')}${helper_1.chalk.grey(`åˆ›å»ºé¡¹ç›®: ${helper_1.chalk.grey.bold(projectName)}`)}`);
            logs.forEach(log => console.log(log));
            console.log();
            // git init
            const gitInitSpinner = ora(`cd ${helper_1.chalk.cyan.bold(projectName)}, æ‰§è¡Œ ${helper_1.chalk.cyan.bold('git init')}`).start();
            process.chdir(projectPath);
            const gitInit = child_process_1.exec('git init');
            gitInit.on('close', code => {
                if (code === 0) {
                    gitInitSpinner.color = 'green';
                    gitInitSpinner.succeed(gitInit.stdout.read());
                }
                else {
                    gitInitSpinner.color = 'red';
                    gitInitSpinner.fail(gitInit.stderr.read());
                }
            });
            const callSuccess = () => {
                console.log(helper_1.chalk.green(`åˆ›å»ºé¡¹ç›® ${helper_1.chalk.green.bold(projectName)} æˆåŠŸï¼`));
                console.log(helper_1.chalk.green(`è¯·è¿›å…¥é¡¹ç›®ç›®å½• ${helper_1.chalk.green.bold(projectName)} å¼€å§‹å·¥ä½œå§ï¼ğŸ˜`));
                if (typeof cb === 'function') {
                    cb();
                }
            };
            if (autoInstall) {
                // packages install
                let command;
                if (isShouldUseYarn) {
                    command = 'yarn install';
                }
                else if (helper_1.shouldUseCnpm()) {
                    command = 'cnpm install';
                }
                else {
                    command = 'npm install';
                }
                const installSpinner = ora(`æ‰§è¡Œå®‰è£…é¡¹ç›®ä¾èµ– ${helper_1.chalk.cyan.bold(command)}, éœ€è¦ä¸€ä¼šå„¿...`).start();
                child_process_1.exec(command, (error, stdout, stderr) => {
                    if (error) {
                        installSpinner.color = 'red';
                        installSpinner.fail(helper_1.chalk.red('å®‰è£…é¡¹ç›®ä¾èµ–å¤±è´¥ï¼Œè¯·è‡ªè¡Œé‡æ–°å®‰è£…ï¼'));
                        console.log(error);
                    }
                    else {
                        installSpinner.color = 'green';
                        installSpinner.succeed('å®‰è£…æˆåŠŸ');
                        console.log(`${stderr}${stdout}`);
                    }
                    callSuccess();
                });
            }
            else {
                callSuccess();
            }
        });
    });
}
exports.createApp = createApp;
//# sourceMappingURL=init.js.map