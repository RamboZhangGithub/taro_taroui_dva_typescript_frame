"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const hooks = require("../constant");
const configValidator_1 = require("../../doctor/configValidator");
exports.default = (ctx) => {
    registerBuildHooks(ctx);
    ctx.registerCommand({
        name: 'build',
        optionsMap: {
            '--type [typeName]': 'Build type, weapp/swan/alipay/tt/qq/jd/h5',
            '--watch': 'Watch mode',
            '--env [env]': 'Value for process.env.NODE_ENV',
            '--blended': 'Blended Taro project in an original MiniApp project'
            // '--port [port]': 'Specified port',
        },
        synopsisList: [
            'taro build --type weapp',
            'taro build --type weapp --watch',
            'taro build --type weapp --env production',
            'taro build --type weapp --blended',
            'taro build native-components --type weapp'
        ],
        fn(opts) {
            return __awaiter(this, void 0, void 0, function* () {
                const { options, config, _ } = opts;
                const { platform, isWatch, blended } = options;
                const { fs, chalk, PROJECT_CONFIG } = ctx.helper;
                const { outputPath, configPath } = ctx.paths;
                if (!configPath || !fs.existsSync(configPath)) {
                    console.log(chalk.red(`找不到项目配置文件${PROJECT_CONFIG}，请确定当前目录是 Taro 项目根目录!`));
                    process.exit(1);
                }
                if (typeof platform !== 'string') {
                    console.log(chalk.red('请传入正确的编译类型！'));
                    process.exit(0);
                }
                // 校验 Taro 项目配置
                const checkResult = yield checkConfig({
                    configPath,
                    projectConfig: ctx.initialConfig
                });
                if (checkResult.lines.length) {
                    const NOTE_VALID = chalk.yellow('[!] ');
                    const NOTE_INVALID = chalk.red('[✗] ');
                    const lineChalk = chalk.hex('#fff');
                    const errorChalk = chalk.hex('#f00');
                    console.log(errorChalk(`Taro 配置有误，请检查！ (${configPath})`));
                    checkResult.lines.forEach(line => {
                        console.log('  ' +
                            (line.valid ? NOTE_VALID : NOTE_INVALID) +
                            lineChalk(line.desc));
                    });
                    process.exit(0);
                }
                const isProduction = process.env.NODE_ENV === 'production' || !isWatch;
                // dist folder
                fs.ensureDirSync(outputPath);
                // is build native components mode?
                const isBuildNativeComp = _[1] === 'native-components';
                yield ctx.applyPlugins(hooks.ON_BUILD_START);
                yield ctx.applyPlugins({
                    name: platform,
                    opts: {
                        config: Object.assign(Object.assign({}, config), { isWatch, mode: isProduction ? 'production' : 'development', blended,
                            isBuildNativeComp, modifyWebpackChain(chain, webpack) {
                                return __awaiter(this, void 0, void 0, function* () {
                                    yield ctx.applyPlugins({
                                        name: hooks.MODIFY_WEBPACK_CHAIN,
                                        initialVal: chain,
                                        opts: {
                                            chain,
                                            webpack
                                        }
                                    });
                                });
                            },
                            modifyBuildAssets(assets, miniPlugin) {
                                return __awaiter(this, void 0, void 0, function* () {
                                    yield ctx.applyPlugins({
                                        name: hooks.MODIFY_BUILD_ASSETS,
                                        initialVal: assets,
                                        opts: {
                                            assets,
                                            miniPlugin
                                        }
                                    });
                                });
                            },
                            modifyMiniConfigs(configMap) {
                                return __awaiter(this, void 0, void 0, function* () {
                                    yield ctx.applyPlugins({
                                        name: hooks.MODIFY_MINI_CONFIGS,
                                        initialVal: configMap,
                                        opts: {
                                            configMap
                                        }
                                    });
                                });
                            },
                            onCompilerMake(compilation) {
                                return __awaiter(this, void 0, void 0, function* () {
                                    yield ctx.applyPlugins({
                                        name: hooks.ON_COMPILER_MAKE,
                                        opts: {
                                            compilation
                                        }
                                    });
                                });
                            },
                            onBuildFinish({ error, stats, isWatch }) {
                                return __awaiter(this, void 0, void 0, function* () {
                                    yield ctx.applyPlugins({
                                        name: hooks.ON_BUILD_FINISH,
                                        opts: {
                                            error,
                                            stats,
                                            isWatch
                                        }
                                    });
                                });
                            } })
                    }
                });
            });
        }
    });
};
function registerBuildHooks(ctx) {
    [
        hooks.MODIFY_WEBPACK_CHAIN,
        hooks.MODIFY_BUILD_ASSETS,
        hooks.MODIFY_MINI_CONFIGS,
        hooks.ON_COMPILER_MAKE,
        hooks.ON_BUILD_START,
        hooks.ON_BUILD_FINISH
    ].forEach(methodName => {
        ctx.registerMethod(methodName);
    });
}
function checkConfig({ projectConfig, configPath }) {
    return __awaiter(this, void 0, void 0, function* () {
        const result = yield configValidator_1.default({
            configPath,
            projectConfig
        });
        return result;
    });
}
//# sourceMappingURL=build.js.map