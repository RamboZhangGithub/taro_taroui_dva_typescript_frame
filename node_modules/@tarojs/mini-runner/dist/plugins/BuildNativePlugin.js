"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const helper_1 = require("@tarojs/helper");
const TaroLoadChunksPlugin_1 = require("./TaroLoadChunksPlugin");
const MiniPlugin_1 = require("./MiniPlugin");
const PLUGIN_NAME = 'BuildNativePlugin';
class BuildNativePlugin extends MiniPlugin_1.default {
    constructor() {
        super(...arguments);
        this.pageLoaderName = '@tarojs/taro-loader/lib/native-component';
    }
    apply(compiler) {
        super.apply(compiler);
        this.addLoadChunksPlugin(compiler);
    }
    run(compiler) {
        this.appConfig = this.getAppConfig();
        this.getPages();
        this.getPagesConfig();
        this.getConfigFiles(compiler);
        this.addEntries();
        this.addLoader(compiler);
    }
    getPages() {
        if (helper_1.isEmptyObject(this.appConfig)) {
            throw new Error('缺少 app 全局配置，请检查！');
        }
        const appPages = this.appConfig.components;
        if (!appPages || !appPages.length) {
            throw new Error('全局配置缺少 components 字段，请检查！');
        }
        if (!this.isWatch) {
            helper_1.printLog("compile" /* COMPILE */, '发现入口', this.getShowPath(this.appEntry));
        }
        const { framework } = this.options;
        this.prerenderPages = new Set();
        this.pages = new Set([
            ...appPages.map(item => {
                const pagePath = helper_1.resolveMainFilePath(path.join(this.options.sourceDir, item), helper_1.FRAMEWORK_EXT_MAP[framework]);
                return {
                    name: item,
                    path: pagePath,
                    isNative: false
                };
            })
        ]);
    }
    // entry 删除 app.js
    addEntries() {
        super.addEntries();
        const deps = this.dependencies;
        for (const [key, dep] of deps.entries()) {
            if (dep.miniType === 'ENTRY') {
                deps.delete(key);
                break;
            }
        }
    }
    addLoadChunksPlugin(compiler) {
        const fileChunks = new Map();
        compiler.hooks.thisCompilation.tap(PLUGIN_NAME, (compilation) => {
            compilation.hooks.afterOptimizeChunks.tap(PLUGIN_NAME, (chunks) => {
                chunks.forEach(chunk => {
                    const id = TaroLoadChunksPlugin_1.getIdOrName(chunk);
                    if (this.options.commonChunks.includes(id))
                        return;
                    const deps = [];
                    chunk._groups.forEach(group => {
                        group.chunks.forEach(chunk => {
                            const currentChunkId = TaroLoadChunksPlugin_1.getIdOrName(chunk);
                            if (id === currentChunkId)
                                return;
                            deps.push({
                                name: currentChunkId
                            });
                        });
                    });
                    fileChunks.set(id, deps);
                });
            });
            compilation.chunkTemplate.hooks.renderWithEntry.tap(PLUGIN_NAME, (modules, chunk) => {
                if (!chunk.entryModule)
                    return;
                // addChunkPages
                if (fileChunks.size) {
                    let source;
                    const id = TaroLoadChunksPlugin_1.getIdOrName(chunk);
                    fileChunks.forEach((v, k) => {
                        if (k === id) {
                            source = TaroLoadChunksPlugin_1.addRequireToSource(id, modules, v);
                        }
                    });
                    return source;
                }
            });
        });
    }
    // 不生成 app.json
    generateConfigFile(compilation, filePath, config) {
        if (filePath === this.appEntry)
            return;
        super.generateConfigFile(compilation, filePath, config);
    }
    // 加载 taro-runtime 前必须先加载端平台插件的 runtime
    addLoader(compiler) {
        compiler.hooks.compilation.tap(PLUGIN_NAME, compilation => {
            compilation.hooks.normalModuleLoader.tap(PLUGIN_NAME, (_loaderContext, module) => {
                if (module.rawRequest === '@tarojs/runtime') {
                    module.loaders.unshift({
                        loader: '@tarojs/taro-loader/lib/taro-runtime',
                        options: {
                            runtimePath: this.options.runtimePath
                        }
                    });
                }
            });
        });
    }
}
exports.default = BuildNativePlugin;
//# sourceMappingURL=BuildNativePlugin.js.map