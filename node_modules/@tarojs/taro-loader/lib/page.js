"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPageConfig = void 0;
const loader_utils_1 = require("loader-utils");
const helper_1 = require("@tarojs/helper");
const path = require("path");
const acorn = require("acorn");
const walk = require("acorn-walk");
const utils_1 = require("./utils");
function default_1(source) {
    const options = loader_utils_1.getOptions(this);
    const { framework, config: loaderConfig } = options;
    const config = getPageConfig(loaderConfig, this.resourcePath);
    const configString = JSON.stringify(config);
    const stringify = (s) => loader_utils_1.stringifyRequest(this, s);
    const { isNeedRawLoader } = utils_1.frameworkMeta[framework];
    // raw is a placeholder loader to locate changed .vue resource
    const raw = path.join(__dirname, 'raw.js');
    const loaders = this.loaders;
    const thisLoaderIndex = loaders.findIndex(item => helper_1.normalizePath(item.path).indexOf('@tarojs/taro-loader/lib/page') >= 0);
    const componentPath = isNeedRawLoader
        ? `${raw}!${this.resourcePath}`
        : this.request.split('!').slice(thisLoaderIndex + 1).join('!');
    const prerender = `
if (typeof PRERENDER !== 'undefined') {
  global._prerender = inst
}`;
    if (framework === 'react' || framework === 'nerv') {
        Object.assign(config, addConfig(source));
    }
    return `import { createPageConfig } from '@tarojs/runtime'
import component from ${stringify(componentPath)}
var config = ${configString};
${config.enableShareTimeline ? 'component.enableShareTimeline = true' : ''}
${config.enableShareAppMessage ? 'component.enableShareAppMessage = true' : ''}
var inst = Page(createPageConfig(component, '${options.name}', {root:{cn:[]}}, config || {}))
${options.prerender ? prerender : ''}
`;
}
exports.default = default_1;
function getPageConfig(configs, resourcePath) {
    const configPath = removeExt(resourcePath) + '.config';
    for (const name in configs) {
        const config = configs[name];
        if (removeExt(configs[name].path) === configPath) {
            return config.content;
        }
    }
    return {};
}
exports.getPageConfig = getPageConfig;
function removeExt(file) {
    return path.join(path.dirname(file), path.basename(file, path.extname(file)));
}
function addConfig(source) {
    const configsMap = {
        enableShareAppMessage: ['onShareAppMessage', 'useShareAppMessage'],
        enableShareTimeline: ['onShareTimeline', 'useShareTimeline']
    };
    const ast = acorn.parse(source, {
        ecmaVersion: 'latest',
        sourceType: 'module'
    });
    const additionConfig = {};
    function check(name) {
        Object.keys(configsMap).forEach(configName => {
            const apis = configsMap[configName];
            if (apis.includes(name)) {
                additionConfig[configName] = true;
            }
        });
    }
    walk.simple(ast, {
        FunctionExpression(node) {
            if (!node.id || !node.id.name)
                return;
            check(node.id.name);
        },
        FunctionDeclaration(node) {
            if (!node.id || !node.id.name)
                return;
            check(node.id.name);
        },
        CallExpression(node) {
            const { callee } = node;
            if (callee.type === 'Identifier') {
                check(callee.name);
            }
            else if (callee.type === 'MemberExpression') {
                if (callee.property.type === 'Identifier') {
                    check(callee.property.name);
                }
                else if (callee.property.type === 'Literal') {
                    check(callee.property.value);
                }
            }
        }
    });
    return additionConfig;
}
//# sourceMappingURL=page.js.map